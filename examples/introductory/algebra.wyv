require stdout

import wyvern.String
import wyvern.collections.map
import wyvern.option

//------------------------------------------------------------------------------
// Types
//------------------------------------------------------------------------------

type Number = Float
type Map = map.Map
type Option = option.Option

//------------------------------------------------------------------------------
// Math Helpers
//------------------------------------------------------------------------------

val nan = 0.0 / 0.0
val pi  = 3.1415926535897
val e   = 2.7182818284590

def intPow(x : Float, n : Float) : Float
  def lp(total : Float, m : Float) : Float
    if (m < 0.1)
      total
     else
      lp(x * total, m - 1.0)
  lp(1.0, n)

def fac(n : Float) : Float
  def lp(total : Float, m : Float) : Float
    if (m < 0.1)
      total
     else
      lp(total * m, m - 1.0)
  lp(1.0, n)

def summation(start : Float, end : Float, term : Float -> Float) : Float
  def lp(total : Float, n : Float) : Float
    if (n > end + 0.1)
      total
     else
      lp(total + term(n), n + 1.0)
  lp(0.0, start)

// Works well for x in [-15, 15]
def exp(x : Float) : Float
  summation(0.0, 50.0,
    n => intPow(x, n) / fac(n)
  )

// Works well for x in [-15, 15]
def log(x : Float) : Float
  val base = (x - 1.0) / (x + 1.0)
  2.0 * summation(0.0, 50.0,
    n => intPow(base, 2.0 * n + 1.0) / (2.0 * n + 1.0)
  )

// Works well for x in [-15, 15]
def realPow(x : Float, y : Float) : Float
  exp(y * log(x))

// Works well for x in [-15, 15]
def logBase(base : Float, x : Float) : Float
  log(x) / log(base)

// Returns x "mod" 2pi
def trigNormalize(x : Float) : Float
  if (x < 0.0)
    trigNormalize(x + 2.0 * pi)
   else
    if (x > 2.0 * pi)
      trigNormalize(x - 2.0 * pi)
     else
      x

def sin(x : Float) : Float
  val xNew = trigNormalize(x)
  summation(0.0, 50.0,
    n => intPow(-1.0, n) * intPow(xNew, 2.0 * n + 1.0) / fac(2.0 * n + 1.0)
  )

def cos(x : Float) : Float
  val xNew = trigNormalize(x)
  summation(0.0, 50.0,
    n => intPow(-1.0, n) * intPow(xNew, 2.0 * n) / fac(2.0 * n)
  )

//------------------------------------------------------------------------------
// Term Type
//------------------------------------------------------------------------------

datatype Term
  Constant(value : Number)
  Variable(name : String)
  Sum(u : Term, v : Term)
  Product(u : Term, v : Term)
  Pow(u : Term, n : Number)
  Sin(u : Term)
  Cos(u : Term)
  Exp(b : Number, u : Term)
  Log(b : Number, u : Term)

// Wrappers to pass the functions around and for typechecking
val Constant : Number => Term = value : Number => Constant(value)
val Variable : String => Term = name : String => Variable(name)
val Sum : Term * Term => Term = (u : Term, v : Term) => Sum(u, v)
val Product : Term * Term => Term = (u : Term, v : Term) => Product(u, v)
val Pow : Term * Number => Term = (u : Term, n : Number) => Pow(u, n)
val Sin : Term => Term = u : Term => Sin(u)
val Cos : Term => Term = u : Term => Cos(u)
val Exp : Number * Term => Term = (b : Number, u : Term) => Exp(b, u)
val Log : Number * Term => Term = (b : Number, u : Term) => Log(b, u)

//------------------------------------------------------------------------------
// String conversion
//------------------------------------------------------------------------------

def toString(t : Term) : String = match t:
  t:Constant => String.ofFloat(t.value)
  t:Variable => t.name
  t:Sum => toString(t.u) + " + " + toString(t.v)
  t:Product => "(" + toString(t.u) + ") * (" + toString(t.v) + ")"
  t:Pow => "(" + toString(t.u) + ")^" + String.ofFloat(t.n)
  t:Sin => "sin(" + toString(t.u) + ")"
  t:Cos => "cos(" + toString(t.u) + ")"
  t:Exp => String.ofFloat(t.b) + "^(" + toString(t.u) + ")"
  t:Log => "log[" + String.ofFloat(t.b) + "](" + toString(t.u) + ")"

//------------------------------------------------------------------------------
// Differentiation
//------------------------------------------------------------------------------

def d(wrt : String, t : Term) : Term = match t:
  t:Constant => Constant(0.0)
  t:Variable => if(t.name == wrt) { Constant(1.0) } else { Constant(0.0) }
  t:Sum => Sum(d(wrt, t.u), d(wrt, t.v))
  t:Product => Sum(Product(t.u, d(wrt, t.v)), Product(t.v, d(wrt, t.u)))
  t:Pow => Product(Product(Constant(t.n), Pow(t.u, t.n - 1.0)), d(wrt, t.u))
  t:Sin => Product(Cos(t.u), d(wrt, t.u))
  t:Cos => Product(Product(Constant(-1.0), Sin(t.u)), d(wrt, t.u))
  t:Exp => Product(Product(Exp(t.b, t.u), Log(e, Constant(t.b))), d(wrt, t.u))
  t:Log => Product(Pow(Product(t.u, Log(e, Constant(t.b))), -1.0), d(wrt, t.u))

//------------------------------------------------------------------------------
// Simplification
//------------------------------------------------------------------------------

datatype TermStep
  Step(term : Term)
  NoStep

// Wrappers to pass the functions around and for typechecking
val Step : Term => TermStep = (t : Term) => Step(t)
val NoStep : TermStep = NoStep()

def firstMatch(ts : TermStep, otherwise : Unit => TermStep) : TermStep
  match ts:
    a:Step => ts
    a:NoStep => otherwise()

def trySimplify1(u : Term, combiner : Term => Term, otherwise : Unit => TermStep) : TermStep
  match simplify(u):
    a:Step => Step(combiner(a.term))
    a:NoStep => otherwise()

def trySimplify2(u : Term, v : Term, combiner : Term * Term -> Term, otherwise : Unit => TermStep) : TermStep
  match simplify(u):
    a:Step => Step(combiner(a.term, v))
    a:NoStep => match simplify(v):
                  b:Step => Step(combiner(u, b.term))
                  b:NoStep => otherwise()

def simplify(t : Term) : TermStep
//  def isZero(a : Term) : Boolean
//    match a:
//      a:Constant => a.value == 0.0
//      default => False
//
//  def isSin2(a : Term) : Boolean
//    match a:
//      a:Pow => if (a.n == 2.0)
//                 match a.u:
//                   u:Sin => True
//                   default => False
//                else
//                 NoStep
//
//  def isCos2(a : Term) : Boolean
//    match a:
//      a:Pow => if (a.n == 2.0)
//                 match a.u:
//                   u:Sin => True
//                   else => False
//                else
//                 NoStep
//
//  def zeroSumRule(a : Term, b : Term) : TermStep
//    if (isZero(a))
//      Step(b)
//     else
//      if (izZero(b))
//        Step(a)
//       else
//        NoStep
//
//  def constantSumRule(a : Term, b : Term) : TermStep
//    match a:
//      a:Constant => match b:
//                      b:Constant => Step(Constant (a.value + b.value))
//                      default => NoStep
//      default => NoStep
//
//  def pythagorasRule(a : Term, b : Term) : TermStep
//    if (isSin2(a) && isCos2(b) || isCos2(a) && isSin2(b))
//      Step(Constant(1.0))
//     else
//      NoStep
//
//  def simplifySum(a : Term, b : Term) : TermStep
//    firstMatch(zeroSumRule(a, b),
//      () => firstMatch(constantSumRule(a, b),
//        () => pythagorasRule(a, b)
//      )
//    )

  match t:
    t:Constant => NoStep
    t:Variable => NoStep
    t:Sum => trySimplify2(t.u, t.v, Sum,
      () => NoStep
    )
    t:Product => trySimplify2(t.u, t.v, Product,
      () => NoStep
    )
    t:Pow => trySimplify1(t.u, uNew : Term => Pow(uNew, t.n),
      () => NoStep
    )
    t:Sin => trySimplify1(t.u, Sin,
      () => NoStep
    )
    t:Cos => trySimplify1(t.u, Cos,
      () => NoStep
    )
    t:Exp => trySimplify1(t.u, uNew : Term => Exp(t.b, uNew),
      () => NoStep
    )
    t:Log => trySimplify1(t.u, uNew : Term => Log(t.b, uNew),
      () => NoStep
    )

def fullySimplify(t : Term) : Term
  match simplify(t):
    a:Step => fullySimplify(a.term)
    a:NoStep => t

//------------------------------------------------------------------------------
// Evaluation
//------------------------------------------------------------------------------

def eval(bindings : Map, t : Term) : Number = match t:
  t:Constant => t.value
  t:Variable => bindings.get(t.name).getOrElse(() => nan)
  t:Sum => eval(bindings, t.u) + eval(bindings, t.v)
  t:Product => eval(bindings, t.u) * eval(bindings, t.v)
  t:Pow => realPow(eval(bindings, t.u), t.n)
  t:Sin => sin(eval(bindings, t.u))
  t:Cos => cos(eval(bindings, t.u))
  t:Exp => realPow(t.b, eval(bindings, t.u))
  t:Log => logBase(t.b, eval(bindings, t.u))

//------------------------------------------------------------------------------
// Examples
//------------------------------------------------------------------------------

val divider : String = "========================================"
val divider2 : String = divider + divider

def printDivider() : Unit
  stdout.print(divider2)
  stdout.println()

def printInfo(t : Term, xVal : Number, yVal : Number) : Unit
  val dxt : Term = d("x", t)
  val dyt : Term = d("y", t)

  val xString : String = String.ofFloat(xVal)
  val yString : String = String.ofFloat(yVal)

  var bindings : Map = map.make((x : String, y : String) => String.equals(x, y))
  bindings.put("x", xVal)
  bindings.put("y", yVal)

  printDivider()

  stdout.print("  Term: ")
  stdout.print(toString(t))
  stdout.println()
  stdout.print("    Fully simplified: ")
  stdout.print(toString(fullySimplify(t)))
  stdout.println()
  stdout.print("    Evaluated @ (x = " + xString + ", y = " + yString + "): ")
  stdout.printFloat(eval(bindings, t))
  stdout.println()

  stdout.println()

  stdout.print("  Derivative w.r.t. x: ")
  stdout.print(toString(dxt))
  stdout.println()
  stdout.print("    Fully simplified: ")
  stdout.print(toString(fullySimplify(dxt)))
  stdout.println()
  stdout.print("    Evaluated @ (x = " + xString + ", y = " + yString + "): ")
  stdout.printFloat(eval(bindings, dxt))
  stdout.println()

  stdout.println()

  stdout.print("  Derivative w.r.t. y: ")
  stdout.print(toString(dyt))
  stdout.println()
  stdout.print("    Fully simplified: ")
  stdout.print(toString(fullySimplify(dyt)))
  stdout.println()
  stdout.print("    Evaluated @ (x = " + xString + ", y = " + yString + "): ")
  stdout.printFloat(eval(bindings, dyt))
  stdout.println()

printInfo(Sin(Pow(Variable("x"), 2.0)), 4.0, 5.0)
printDivider()
